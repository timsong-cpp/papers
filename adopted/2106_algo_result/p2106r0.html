<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-02-13" />
  <title>Alternative wording for GB315 and GB316</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Alternative wording for GB315 and GB316</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>P2106R0</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2020-02-13</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      LWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Tim Song<br>&lt;<a href="mailto:t.canens.cpp@gmail.com" class="email">t.canens.cpp@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<h1 id="introduction" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>This paper provides alternative wording for NB comments <a href="https://github.com/cplusplus/nbballot/issues/311">GB315</a> and <a href="https://github.com/cplusplus/nbballot/issues/312">GB316</a>, based on LEWG’s direction in Prague.</p>
<h1 id="wording" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> Wording<a href="#wording" class="self-link"></a></h1>
<p>This wording is relative to <span class="citation" data-cites="N4849">[<a href="#ref-N4849" role="doc-biblioref">N4849</a>]</span>.</p>
<p>Edit <span>25.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a></span> as indicated:</p>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a> #include &lt;initializer_list&gt;</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a> namespace std {</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="va">+  namespace ranges {</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="va">+</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="va">+    // [algorithms.results], algorithm result types</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="va">+    template&lt;class I, class F&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="va">+    struct in_fun_result;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="va">+</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="va">+    template&lt;class I1, class I2&gt;</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="va">+    struct in_in_result;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="va">+</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="va">+    template&lt;class I, class O&gt;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="va">+    struct in_out_result;</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="va">+</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="va">+    template&lt;class I1, class I2, class O&gt;</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="va">+    struct in_in_out_result;</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="va">+</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="va">+    template&lt;class I, class O1, class O2&gt;</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="va">+    struct in_out_out_result;</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="va">+</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="va">+    template&lt;class T&gt;</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="va">+    struct min_max_result;</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="va">+</span></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="va">+    template&lt;class I&gt;</span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="va">+    struct in_found_result;</span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="va">+  }</span></span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="va">+</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>   <em>[…]</em></span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a>   namespace ranges {</span>
<span id="cb1-33"><a href="#cb1-33"></a>     template&lt;class I, class F&gt;</span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="va">+    using for_each_result = in_fun_result&lt;I, F&gt;;</span></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="st">-    struct for_each_result {</span></span>
<span id="cb1-36"><a href="#cb1-36"></a><span class="st">-      [[no_unique_address]] I in;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="st">-      [[no_unique_address]] F fun;</span></span>
<span id="cb1-38"><a href="#cb1-38"></a><span class="st">-</span></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="st">-      template&lt;class I2, class F2&gt;</span></span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="st">-        requires convertible_to&lt;const I&amp;, I2&gt; &amp;&amp; convertible_to&lt;const F&amp;, F2&gt;</span></span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="st">-        operator for_each_result&lt;I2, F2&gt;() const &amp; {</span></span>
<span id="cb1-42"><a href="#cb1-42"></a><span class="st">-          return {in, fun};</span></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="st">-        }</span></span>
<span id="cb1-44"><a href="#cb1-44"></a><span class="st">-</span></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="st">-      template&lt;class I2, class F2&gt;</span></span>
<span id="cb1-46"><a href="#cb1-46"></a><span class="st">-        requires convertible_to&lt;I, I2&gt; &amp;&amp; convertible_to&lt;F, F2&gt;</span></span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="st">-        operator for_each_result&lt;I2, F2&gt;() &amp;&amp; {</span></span>
<span id="cb1-48"><a href="#cb1-48"></a><span class="st">-          return {std::move(in), std::move(fun)};</span></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="st">-        }</span></span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="st">-    };</span></span>
<span id="cb1-51"><a href="#cb1-51"></a></span>
<span id="cb1-52"><a href="#cb1-52"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,</span>
<span id="cb1-53"><a href="#cb1-53"></a>              indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;</span>
<span id="cb1-54"><a href="#cb1-54"></a>       constexpr for_each_result&lt;I, Fun&gt;</span>
<span id="cb1-55"><a href="#cb1-55"></a>         for_each(I first, S last, Fun f, Proj proj = {});</span>
<span id="cb1-56"><a href="#cb1-56"></a>     template&lt;input_range R, class Proj = identity,</span>
<span id="cb1-57"><a href="#cb1-57"></a>              indirectly_unary_invocable&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Fun&gt;</span>
<span id="cb1-58"><a href="#cb1-58"></a>       constexpr for_each_result&lt;safe_iterator_t&lt;R&gt;, Fun&gt;</span>
<span id="cb1-59"><a href="#cb1-59"></a>         for_each(R&amp;&amp; r, Fun f, Proj proj = {});</span>
<span id="cb1-60"><a href="#cb1-60"></a>   }</span>
<span id="cb1-61"><a href="#cb1-61"></a></span>
<span id="cb1-62"><a href="#cb1-62"></a>   <em>[…]</em></span>
<span id="cb1-63"><a href="#cb1-63"></a></span>
<span id="cb1-64"><a href="#cb1-64"></a>   namespace ranges {</span>
<span id="cb1-65"><a href="#cb1-65"></a>     template&lt;class I1, class I2&gt;</span>
<span id="cb1-66"><a href="#cb1-66"></a><span class="va">+    using mismatch_result = in_in_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-67"><a href="#cb1-67"></a><span class="st">-    struct mismatch_result {</span></span>
<span id="cb1-68"><a href="#cb1-68"></a><span class="st">-      [[no_unique_address]] I1 in1;</span></span>
<span id="cb1-69"><a href="#cb1-69"></a><span class="st">-      [[no_unique_address]] I2 in2;</span></span>
<span id="cb1-70"><a href="#cb1-70"></a><span class="st">-</span></span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="st">-      template&lt;class II1, class II2&gt;</span></span>
<span id="cb1-72"><a href="#cb1-72"></a><span class="st">-        requires convertible_to&lt;const I1&amp;, II1&gt; &amp;&amp; convertible_to&lt;const I2&amp;, II2&gt;</span></span>
<span id="cb1-73"><a href="#cb1-73"></a><span class="st">-        operator mismatch_result&lt;II1, II2&gt;() const &amp; {</span></span>
<span id="cb1-74"><a href="#cb1-74"></a><span class="st">-          return {in1, in2};</span></span>
<span id="cb1-75"><a href="#cb1-75"></a><span class="st">-        }</span></span>
<span id="cb1-76"><a href="#cb1-76"></a><span class="st">-</span></span>
<span id="cb1-77"><a href="#cb1-77"></a><span class="st">-      template&lt;class II1, class II2&gt;</span></span>
<span id="cb1-78"><a href="#cb1-78"></a><span class="st">-        requires convertible_to&lt;I1, II1&gt; &amp;&amp; convertible_to&lt;I2, II2&gt;</span></span>
<span id="cb1-79"><a href="#cb1-79"></a><span class="st">-        operator mismatch_result&lt;II1, II2&gt;() &amp;&amp; {</span></span>
<span id="cb1-80"><a href="#cb1-80"></a><span class="st">-          return {std::move(in1), std::move(in2)};</span></span>
<span id="cb1-81"><a href="#cb1-81"></a><span class="st">-        }</span></span>
<span id="cb1-82"><a href="#cb1-82"></a><span class="st">-    };</span></span>
<span id="cb1-83"><a href="#cb1-83"></a></span>
<span id="cb1-84"><a href="#cb1-84"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-85"><a href="#cb1-85"></a>              class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-86"><a href="#cb1-86"></a>       requires indirectly_comparable&lt;I1, I2, Pred, Proj1, Proj2&gt;</span>
<span id="cb1-87"><a href="#cb1-87"></a>       constexpr mismatch_result&lt;I1, I2&gt;</span>
<span id="cb1-88"><a href="#cb1-88"></a>         mismatch(I1 first1, S1 last1, I2 first2, S2 last2, Pred pred = {},</span>
<span id="cb1-89"><a href="#cb1-89"></a>                  Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-90"><a href="#cb1-90"></a>     template&lt;input_range R1, input_range R2,</span>
<span id="cb1-91"><a href="#cb1-91"></a>              class Pred = ranges::equal_to, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-92"><a href="#cb1-92"></a>       requires indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Pred, Proj1, Proj2&gt;</span>
<span id="cb1-93"><a href="#cb1-93"></a>       constexpr mismatch_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;</span>
<span id="cb1-94"><a href="#cb1-94"></a>         mismatch(R1&amp;&amp; r1, R2&amp;&amp; r2, Pred pred = {},</span>
<span id="cb1-95"><a href="#cb1-95"></a>                  Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-96"><a href="#cb1-96"></a>   }</span>
<span id="cb1-97"><a href="#cb1-97"></a></span>
<span id="cb1-98"><a href="#cb1-98"></a>   <em>[…]</em></span>
<span id="cb1-99"><a href="#cb1-99"></a></span>
<span id="cb1-100"><a href="#cb1-100"></a>   namespace ranges {</span>
<span id="cb1-101"><a href="#cb1-101"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-102"><a href="#cb1-102"></a><span class="va">+    using copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-103"><a href="#cb1-103"></a><span class="st">-    struct copy_result {</span></span>
<span id="cb1-104"><a href="#cb1-104"></a><span class="st">-      [[no_unique_address]] I in;</span></span>
<span id="cb1-105"><a href="#cb1-105"></a><span class="st">-      [[no_unique_address]] O out;</span></span>
<span id="cb1-106"><a href="#cb1-106"></a><span class="st">-</span></span>
<span id="cb1-107"><a href="#cb1-107"></a><span class="st">-     template&lt;class I2, class O2&gt;</span></span>
<span id="cb1-108"><a href="#cb1-108"></a><span class="st">-        requires convertible_to&lt;const I&amp;, I2&gt; &amp;&amp; convertible_to&lt;const O&amp;, O2&gt;</span></span>
<span id="cb1-109"><a href="#cb1-109"></a><span class="st">-        operator copy_result&lt;I2, O2&gt;() const &amp; {</span></span>
<span id="cb1-110"><a href="#cb1-110"></a><span class="st">-          return {in, out};</span></span>
<span id="cb1-111"><a href="#cb1-111"></a><span class="st">-        }</span></span>
<span id="cb1-112"><a href="#cb1-112"></a><span class="st">-</span></span>
<span id="cb1-113"><a href="#cb1-113"></a><span class="st">-     template&lt;class I2, class O2&gt;</span></span>
<span id="cb1-114"><a href="#cb1-114"></a><span class="st">-        requires convertible_to&lt;I, I2&gt; &amp;&amp; convertible_to&lt;O, O2&gt;</span></span>
<span id="cb1-115"><a href="#cb1-115"></a><span class="st">-        operator copy_result&lt;I2, O2&gt;() &amp;&amp; {</span></span>
<span id="cb1-116"><a href="#cb1-116"></a><span class="st">-          return {std::move(in), std::move(out)};</span></span>
<span id="cb1-117"><a href="#cb1-117"></a><span class="st">-        }</span></span>
<span id="cb1-118"><a href="#cb1-118"></a><span class="st">-    };</span></span>
<span id="cb1-119"><a href="#cb1-119"></a></span>
<span id="cb1-120"><a href="#cb1-120"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;</span>
<span id="cb1-121"><a href="#cb1-121"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-122"><a href="#cb1-122"></a>       constexpr copy_result&lt;I, O&gt;</span>
<span id="cb1-123"><a href="#cb1-123"></a>         copy(I first, S last, O result);</span>
<span id="cb1-124"><a href="#cb1-124"></a>     template&lt;input_range R, weakly_incrementable O&gt;</span>
<span id="cb1-125"><a href="#cb1-125"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-126"><a href="#cb1-126"></a>       constexpr copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-127"><a href="#cb1-127"></a>         copy(R&amp;&amp; r, O result);</span>
<span id="cb1-128"><a href="#cb1-128"></a>   }</span>
<span id="cb1-129"><a href="#cb1-129"></a></span>
<span id="cb1-130"><a href="#cb1-130"></a>   <em>[…]</em></span>
<span id="cb1-131"><a href="#cb1-131"></a></span>
<span id="cb1-132"><a href="#cb1-132"></a>   namespace ranges {</span>
<span id="cb1-133"><a href="#cb1-133"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-134"><a href="#cb1-134"></a><span class="st">-    using copy_n_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-135"><a href="#cb1-135"></a><span class="va">+    using copy_n_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-136"><a href="#cb1-136"></a></span>
<span id="cb1-137"><a href="#cb1-137"></a>     template&lt;input_iterator I, weakly_incrementable O&gt;</span>
<span id="cb1-138"><a href="#cb1-138"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-139"><a href="#cb1-139"></a>       constexpr copy_n_result&lt;I, O&gt;</span>
<span id="cb1-140"><a href="#cb1-140"></a>         copy_n(I first, iter_difference_t&lt;I&gt; n, O result);</span>
<span id="cb1-141"><a href="#cb1-141"></a>   }</span>
<span id="cb1-142"><a href="#cb1-142"></a></span>
<span id="cb1-143"><a href="#cb1-143"></a>   <em>[…]</em></span>
<span id="cb1-144"><a href="#cb1-144"></a></span>
<span id="cb1-145"><a href="#cb1-145"></a>   namespace ranges {</span>
<span id="cb1-146"><a href="#cb1-146"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-147"><a href="#cb1-147"></a><span class="st">-    using copy_if_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-148"><a href="#cb1-148"></a><span class="va">+    using copy_if_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-149"><a href="#cb1-149"></a></span>
<span id="cb1-150"><a href="#cb1-150"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O, class Proj = identity,</span>
<span id="cb1-151"><a href="#cb1-151"></a>              indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-152"><a href="#cb1-152"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-153"><a href="#cb1-153"></a>       constexpr copy_if_result&lt;I, O&gt;</span>
<span id="cb1-154"><a href="#cb1-154"></a>         copy_if(I first, S last, O result, Pred pred, Proj proj = {});</span>
<span id="cb1-155"><a href="#cb1-155"></a>     template&lt;input_range R, weakly_incrementable O, class Proj = identity,</span>
<span id="cb1-156"><a href="#cb1-156"></a>              indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-157"><a href="#cb1-157"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-158"><a href="#cb1-158"></a>       constexpr copy_if_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-159"><a href="#cb1-159"></a>         copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});</span>
<span id="cb1-160"><a href="#cb1-160"></a>   }</span>
<span id="cb1-161"><a href="#cb1-161"></a></span>
<span id="cb1-162"><a href="#cb1-162"></a>   <em>[…]</em></span>
<span id="cb1-163"><a href="#cb1-163"></a></span>
<span id="cb1-164"><a href="#cb1-164"></a>   namespace ranges {</span>
<span id="cb1-165"><a href="#cb1-165"></a>     template&lt;class I1, class I2&gt;</span>
<span id="cb1-166"><a href="#cb1-166"></a><span class="st">-    using copy_backward_result = copy_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-167"><a href="#cb1-167"></a><span class="va">+    using copy_backward_result = in_out_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-168"><a href="#cb1-168"></a></span>
<span id="cb1-169"><a href="#cb1-169"></a>     template&lt;bidirectional_iterator I1, sentinel_for&lt;I1&gt; S1, bidirectional_iterator I2&gt;</span>
<span id="cb1-170"><a href="#cb1-170"></a>       requires indirectly_copyable&lt;I1, I2&gt;</span>
<span id="cb1-171"><a href="#cb1-171"></a>       constexpr copy_backward_result&lt;I1, I2&gt;</span>
<span id="cb1-172"><a href="#cb1-172"></a>         copy_backward(I1 first, S1 last, I2 result);</span>
<span id="cb1-173"><a href="#cb1-173"></a>     template&lt;bidirectional_range R, bidirectional_iterator I&gt;</span>
<span id="cb1-174"><a href="#cb1-174"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, I&gt;</span>
<span id="cb1-175"><a href="#cb1-175"></a>       constexpr copy_backward_result&lt;safe_iterator_t&lt;R&gt;, I&gt;</span>
<span id="cb1-176"><a href="#cb1-176"></a>         copy_backward(R&amp;&amp; r, I result);</span>
<span id="cb1-177"><a href="#cb1-177"></a>   }</span>
<span id="cb1-178"><a href="#cb1-178"></a></span>
<span id="cb1-179"><a href="#cb1-179"></a>   <em>[…]</em></span>
<span id="cb1-180"><a href="#cb1-180"></a></span>
<span id="cb1-181"><a href="#cb1-181"></a>   namespace ranges {</span>
<span id="cb1-182"><a href="#cb1-182"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-183"><a href="#cb1-183"></a><span class="st">-    using move_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-184"><a href="#cb1-184"></a><span class="va">+    using move_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-185"><a href="#cb1-185"></a></span>
<span id="cb1-186"><a href="#cb1-186"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;</span>
<span id="cb1-187"><a href="#cb1-187"></a>       requires indirectly_movable&lt;I, O&gt;</span>
<span id="cb1-188"><a href="#cb1-188"></a>       constexpr move_result&lt;I, O&gt;</span>
<span id="cb1-189"><a href="#cb1-189"></a>         move(I first, S last, O result);</span>
<span id="cb1-190"><a href="#cb1-190"></a>     template&lt;input_range R, weakly_incrementable O&gt;</span>
<span id="cb1-191"><a href="#cb1-191"></a>       requires indirectly_movable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-192"><a href="#cb1-192"></a>       constexpr move_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-193"><a href="#cb1-193"></a>         move(R&amp;&amp; r, O result);</span>
<span id="cb1-194"><a href="#cb1-194"></a>   }</span>
<span id="cb1-195"><a href="#cb1-195"></a></span>
<span id="cb1-196"><a href="#cb1-196"></a>   <em>[…]</em></span>
<span id="cb1-197"><a href="#cb1-197"></a></span>
<span id="cb1-198"><a href="#cb1-198"></a>   namespace ranges {</span>
<span id="cb1-199"><a href="#cb1-199"></a>     template&lt;class I1, class I2&gt;</span>
<span id="cb1-200"><a href="#cb1-200"></a><span class="st">-    using move_backward_result = copy_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-201"><a href="#cb1-201"></a><span class="va">+    using move_backward_result = in_out_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-202"><a href="#cb1-202"></a></span>
<span id="cb1-203"><a href="#cb1-203"></a>     template&lt;bidirectional_iterator I1, sentinel_for&lt;I1&gt; S1, bidirectional_iterator I2&gt;</span>
<span id="cb1-204"><a href="#cb1-204"></a>       requires indirectly_movable&lt;I1, I2&gt;</span>
<span id="cb1-205"><a href="#cb1-205"></a>       constexpr move_backward_result&lt;I1, I2&gt;</span>
<span id="cb1-206"><a href="#cb1-206"></a>         move_backward(I1 first, S1 last, I2 result);</span>
<span id="cb1-207"><a href="#cb1-207"></a>     template&lt;bidirectional_range R, bidirectional_iterator I&gt;</span>
<span id="cb1-208"><a href="#cb1-208"></a>       requires indirectly_movable&lt;iterator_t&lt;R&gt;, I&gt;</span>
<span id="cb1-209"><a href="#cb1-209"></a>       constexpr move_backward_result&lt;safe_iterator_t&lt;R&gt;, I&gt;</span>
<span id="cb1-210"><a href="#cb1-210"></a>         move_backward(R&amp;&amp; r, I result);</span>
<span id="cb1-211"><a href="#cb1-211"></a>   }</span>
<span id="cb1-212"><a href="#cb1-212"></a></span>
<span id="cb1-213"><a href="#cb1-213"></a>   <em>[…]</em></span>
<span id="cb1-214"><a href="#cb1-214"></a></span>
<span id="cb1-215"><a href="#cb1-215"></a>   namespace ranges {</span>
<span id="cb1-216"><a href="#cb1-216"></a>     template&lt;class I1, class I2&gt;</span>
<span id="cb1-217"><a href="#cb1-217"></a><span class="st">-    using swap_ranges_result = mismatch_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-218"><a href="#cb1-218"></a><span class="va">+    using swap_ranges_result = in_in_result&lt;I1, I2&gt;;</span></span>
<span id="cb1-219"><a href="#cb1-219"></a></span>
<span id="cb1-220"><a href="#cb1-220"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2&gt;</span>
<span id="cb1-221"><a href="#cb1-221"></a>       requires indirectly_swappable&lt;I1, I2&gt;</span>
<span id="cb1-222"><a href="#cb1-222"></a>       constexpr swap_ranges_result&lt;I1, I2&gt;</span>
<span id="cb1-223"><a href="#cb1-223"></a>         swap_ranges(I1 first1, S1 last1, I2 first2, S2 last2);</span>
<span id="cb1-224"><a href="#cb1-224"></a>     template&lt;input_range R1, input_range R2&gt;</span>
<span id="cb1-225"><a href="#cb1-225"></a>       requires indirectly_swappable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt;</span>
<span id="cb1-226"><a href="#cb1-226"></a>       constexpr swap_ranges_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;</span>
<span id="cb1-227"><a href="#cb1-227"></a>         swap_ranges(R1&amp;&amp; r1, R2&amp;&amp; r2);</span>
<span id="cb1-228"><a href="#cb1-228"></a>   }</span>
<span id="cb1-229"><a href="#cb1-229"></a></span>
<span id="cb1-230"><a href="#cb1-230"></a>   <em>[…]</em></span>
<span id="cb1-231"><a href="#cb1-231"></a></span>
<span id="cb1-232"><a href="#cb1-232"></a>   namespace ranges {</span>
<span id="cb1-233"><a href="#cb1-233"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-234"><a href="#cb1-234"></a><span class="st">-    using unary_transform_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-235"><a href="#cb1-235"></a><span class="va">+    using unary_transform_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-236"><a href="#cb1-236"></a></span>
<span id="cb1-237"><a href="#cb1-237"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,</span>
<span id="cb1-238"><a href="#cb1-238"></a>              copy_constructible F, class Proj = identity&gt;</span>
<span id="cb1-239"><a href="#cb1-239"></a>       requires writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I, Proj&gt;&gt;&gt;</span>
<span id="cb1-240"><a href="#cb1-240"></a>       constexpr unary_transform_result&lt;I, O&gt;</span>
<span id="cb1-241"><a href="#cb1-241"></a>         transform(I first1, S last1, O result, F op, Proj proj = {});</span>
<span id="cb1-242"><a href="#cb1-242"></a>     template&lt;input_range R, weakly_incrementable O, copy_constructible F,</span>
<span id="cb1-243"><a href="#cb1-243"></a>              class Proj = identity&gt;</span>
<span id="cb1-244"><a href="#cb1-244"></a>       requires writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt;&gt;</span>
<span id="cb1-245"><a href="#cb1-245"></a>       constexpr unary_transform_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-246"><a href="#cb1-246"></a>         transform(R&amp;&amp; r, O result, F op, Proj proj = {});</span>
<span id="cb1-247"><a href="#cb1-247"></a></span>
<span id="cb1-248"><a href="#cb1-248"></a>     template&lt;class I1, class I2, class O&gt;</span>
<span id="cb1-249"><a href="#cb1-249"></a><span class="va">+    using binary_transform_result = in_in_out_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-250"><a href="#cb1-250"></a><span class="st">-    struct binary_transform_result {</span></span>
<span id="cb1-251"><a href="#cb1-251"></a><span class="st">-      [[no_unique_address]] I1 in1;</span></span>
<span id="cb1-252"><a href="#cb1-252"></a><span class="st">-      [[no_unique_address]] I2 in2;</span></span>
<span id="cb1-253"><a href="#cb1-253"></a><span class="st">-      [[no_unique_address]] O  out;</span></span>
<span id="cb1-254"><a href="#cb1-254"></a><span class="st">-      template&lt;class II1, class II2, class OO&gt;</span></span>
<span id="cb1-255"><a href="#cb1-255"></a><span class="st">-        requires convertible_to&lt;const I1&amp;, II1&gt; &amp;&amp;</span></span>
<span id="cb1-256"><a href="#cb1-256"></a><span class="st">-          convertible_to&lt;const I2&amp;, II2&gt; &amp;&amp; convertible_to&lt;const O&amp;, OO&gt;</span></span>
<span id="cb1-257"><a href="#cb1-257"></a><span class="st">-        operator binary_transform_result&lt;II1, II2, OO&gt;() const &amp; {</span></span>
<span id="cb1-258"><a href="#cb1-258"></a><span class="st">-          return {in1, in2, out};</span></span>
<span id="cb1-259"><a href="#cb1-259"></a><span class="st">-        }</span></span>
<span id="cb1-260"><a href="#cb1-260"></a><span class="st">-</span></span>
<span id="cb1-261"><a href="#cb1-261"></a><span class="st">-      template&lt;class II1, class II2, class OO&gt;</span></span>
<span id="cb1-262"><a href="#cb1-262"></a><span class="st">-        requires convertible_to&lt;I1, II1&gt; &amp;&amp;</span></span>
<span id="cb1-263"><a href="#cb1-263"></a><span class="st">-          convertible_to&lt;I2, II2&gt; &amp;&amp; convertible_to&lt;O, OO&gt;</span></span>
<span id="cb1-264"><a href="#cb1-264"></a><span class="st">-        operator binary_transform_result&lt;II1, II2, OO&gt;() &amp;&amp; {</span></span>
<span id="cb1-265"><a href="#cb1-265"></a><span class="st">-          return {std::move(in1), std::move(in2), std::move(out)};</span></span>
<span id="cb1-266"><a href="#cb1-266"></a><span class="st">-        }</span></span>
<span id="cb1-267"><a href="#cb1-267"></a><span class="st">-    };</span></span>
<span id="cb1-268"><a href="#cb1-268"></a></span>
<span id="cb1-269"><a href="#cb1-269"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-270"><a href="#cb1-270"></a>              weakly_incrementable O, copy_constructible F, class Proj1 = identity,</span>
<span id="cb1-271"><a href="#cb1-271"></a>              class Proj2 = identity&gt;</span>
<span id="cb1-272"><a href="#cb1-272"></a>       requires writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;I1, Proj1&gt;,</span>
<span id="cb1-273"><a href="#cb1-273"></a>                                              projected&lt;I2, Proj2&gt;&gt;&gt;</span>
<span id="cb1-274"><a href="#cb1-274"></a>       constexpr binary_transform_result&lt;I1, I2, O&gt;</span>
<span id="cb1-275"><a href="#cb1-275"></a>         transform(I1 first1, S1 last1, I2 first2, S2 last2, O result,</span>
<span id="cb1-276"><a href="#cb1-276"></a>                   F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-277"><a href="#cb1-277"></a>     template&lt;input_range R1, input_range R2, weakly_incrementable O,</span>
<span id="cb1-278"><a href="#cb1-278"></a>              copy_constructible F, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-279"><a href="#cb1-279"></a>       requires writable&lt;O, indirect_result_t&lt;F&amp;, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,</span>
<span id="cb1-280"><a href="#cb1-280"></a>                                              projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;&gt;</span>
<span id="cb1-281"><a href="#cb1-281"></a>       constexpr binary_transform_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;</span>
<span id="cb1-282"><a href="#cb1-282"></a>         transform(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,</span>
<span id="cb1-283"><a href="#cb1-283"></a>                   F binary_op, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-284"><a href="#cb1-284"></a>   }</span>
<span id="cb1-285"><a href="#cb1-285"></a></span>
<span id="cb1-286"><a href="#cb1-286"></a>   <em>[…]</em></span>
<span id="cb1-287"><a href="#cb1-287"></a></span>
<span id="cb1-288"><a href="#cb1-288"></a>   namespace ranges {</span>
<span id="cb1-289"><a href="#cb1-289"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-290"><a href="#cb1-290"></a><span class="st">-     using replace_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-291"><a href="#cb1-291"></a><span class="va">+     using replace_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-292"><a href="#cb1-292"></a></span>
<span id="cb1-293"><a href="#cb1-293"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T1, class T2,</span>
<span id="cb1-294"><a href="#cb1-294"></a>              output_iterator&lt;const T2&amp;&gt; O, class Proj = identity&gt;</span>
<span id="cb1-295"><a href="#cb1-295"></a>       requires indirectly_copyable&lt;I, O&gt; &amp;&amp;</span>
<span id="cb1-296"><a href="#cb1-296"></a>                indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T1*&gt;</span>
<span id="cb1-297"><a href="#cb1-297"></a>       constexpr replace_copy_result&lt;I, O&gt;</span>
<span id="cb1-298"><a href="#cb1-298"></a>         replace_copy(I first, S last, O result, const T1&amp; old_value, const T2&amp; new_value,</span>
<span id="cb1-299"><a href="#cb1-299"></a>                      Proj proj = {});</span>
<span id="cb1-300"><a href="#cb1-300"></a>     template&lt;input_range R, class T1, class T2, output_iterator&lt;const T2&amp;&gt; O,</span>
<span id="cb1-301"><a href="#cb1-301"></a>              class Proj = identity&gt;</span>
<span id="cb1-302"><a href="#cb1-302"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;</span>
<span id="cb1-303"><a href="#cb1-303"></a>                indirect_binary_predicate&lt;ranges::equal_to,</span>
<span id="cb1-304"><a href="#cb1-304"></a>                                          projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T1*&gt;</span>
<span id="cb1-305"><a href="#cb1-305"></a>       constexpr replace_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-306"><a href="#cb1-306"></a>         replace_copy(R&amp;&amp; r, O result, const T1&amp; old_value, const T2&amp; new_value,</span>
<span id="cb1-307"><a href="#cb1-307"></a>                      Proj proj = {});</span>
<span id="cb1-308"><a href="#cb1-308"></a></span>
<span id="cb1-309"><a href="#cb1-309"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-310"><a href="#cb1-310"></a><span class="st">-    using replace_copy_if_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-311"><a href="#cb1-311"></a><span class="va">+    using replace_copy_if_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-312"><a href="#cb1-312"></a></span>
<span id="cb1-313"><a href="#cb1-313"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, class T, output_iterator&lt;const T&amp;&gt; O,</span>
<span id="cb1-314"><a href="#cb1-314"></a>              class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-315"><a href="#cb1-315"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-316"><a href="#cb1-316"></a>       constexpr replace_copy_if_result&lt;I, O&gt;</span>
<span id="cb1-317"><a href="#cb1-317"></a>         replace_copy_if(I first, S last, O result, Pred pred, const T&amp; new_value,</span>
<span id="cb1-318"><a href="#cb1-318"></a>                         Proj proj = {});</span>
<span id="cb1-319"><a href="#cb1-319"></a>     template&lt;input_range R, class T, output_iterator&lt;const T&amp;&gt; O, class Proj = identity,</span>
<span id="cb1-320"><a href="#cb1-320"></a>              indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-321"><a href="#cb1-321"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-322"><a href="#cb1-322"></a>       constexpr replace_copy_if_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-323"><a href="#cb1-323"></a>         replace_copy_if(R&amp;&amp; r, O result, Pred pred, const T&amp; new_value,</span>
<span id="cb1-324"><a href="#cb1-324"></a>                         Proj proj = {});</span>
<span id="cb1-325"><a href="#cb1-325"></a>   }</span>
<span id="cb1-326"><a href="#cb1-326"></a></span>
<span id="cb1-327"><a href="#cb1-327"></a>   <em>[…]</em></span>
<span id="cb1-328"><a href="#cb1-328"></a></span>
<span id="cb1-329"><a href="#cb1-329"></a>   namespace ranges {</span>
<span id="cb1-330"><a href="#cb1-330"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-331"><a href="#cb1-331"></a><span class="st">-    using remove_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-332"><a href="#cb1-332"></a><span class="va">+    using remove_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-333"><a href="#cb1-333"></a></span>
<span id="cb1-334"><a href="#cb1-334"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O, class T,</span>
<span id="cb1-335"><a href="#cb1-335"></a>              class Proj = identity&gt;</span>
<span id="cb1-336"><a href="#cb1-336"></a>       requires indirectly_copyable&lt;I, O&gt; &amp;&amp;</span>
<span id="cb1-337"><a href="#cb1-337"></a>                indirect_binary_predicate&lt;ranges::equal_to, projected&lt;I, Proj&gt;, const T*&gt;</span>
<span id="cb1-338"><a href="#cb1-338"></a>       constexpr remove_copy_result&lt;I, O&gt;</span>
<span id="cb1-339"><a href="#cb1-339"></a>         remove_copy(I first, S last, O result, const T&amp; value, Proj proj = {});</span>
<span id="cb1-340"><a href="#cb1-340"></a>     template&lt;input_range R, weakly_incrementable O, class T, class Proj = identity&gt;</span>
<span id="cb1-341"><a href="#cb1-341"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;</span>
<span id="cb1-342"><a href="#cb1-342"></a>                indirect_binary_predicate&lt;ranges::equal_to,</span>
<span id="cb1-343"><a href="#cb1-343"></a>                                          projected&lt;iterator_t&lt;R&gt;, Proj&gt;, const T*&gt;</span>
<span id="cb1-344"><a href="#cb1-344"></a>       constexpr remove_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-345"><a href="#cb1-345"></a>         remove_copy(R&amp;&amp; r, O result, const T&amp; value, Proj proj = {});</span>
<span id="cb1-346"><a href="#cb1-346"></a></span>
<span id="cb1-347"><a href="#cb1-347"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-348"><a href="#cb1-348"></a><span class="st">-    using remove_copy_if_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-349"><a href="#cb1-349"></a><span class="va">+    using remove_copy_if_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-350"><a href="#cb1-350"></a></span>
<span id="cb1-351"><a href="#cb1-351"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O,</span>
<span id="cb1-352"><a href="#cb1-352"></a>              class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-353"><a href="#cb1-353"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-354"><a href="#cb1-354"></a>       constexpr remove_copy_if_result&lt;I, O&gt;</span>
<span id="cb1-355"><a href="#cb1-355"></a>         remove_copy_if(I first, S last, O result, Pred pred, Proj proj = {});</span>
<span id="cb1-356"><a href="#cb1-356"></a>     template&lt;input_range R, weakly_incrementable O, class Proj = identity,</span>
<span id="cb1-357"><a href="#cb1-357"></a>              indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-358"><a href="#cb1-358"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-359"><a href="#cb1-359"></a>       constexpr remove_copy_if_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-360"><a href="#cb1-360"></a>         remove_copy_if(R&amp;&amp; r, O result, Pred pred, Proj proj = {});</span>
<span id="cb1-361"><a href="#cb1-361"></a>   }</span>
<span id="cb1-362"><a href="#cb1-362"></a></span>
<span id="cb1-363"><a href="#cb1-363"></a>   <em>[…]</em></span>
<span id="cb1-364"><a href="#cb1-364"></a></span>
<span id="cb1-365"><a href="#cb1-365"></a>   namespace ranges {</span>
<span id="cb1-366"><a href="#cb1-366"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-367"><a href="#cb1-367"></a><span class="st">-    using unique_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-368"><a href="#cb1-368"></a><span class="va">+    using unique_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-369"><a href="#cb1-369"></a></span>
<span id="cb1-370"><a href="#cb1-370"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O, class Proj = identity,</span>
<span id="cb1-371"><a href="#cb1-371"></a>              indirect_equivalence_relation&lt;projected&lt;I, Proj&gt;&gt; C = ranges::equal_to&gt;</span>
<span id="cb1-372"><a href="#cb1-372"></a>       requires indirectly_copyable&lt;I, O&gt; &amp;&amp;</span>
<span id="cb1-373"><a href="#cb1-373"></a>                (forward_iterator&lt;I&gt; ||</span>
<span id="cb1-374"><a href="#cb1-374"></a>                 (input_iterator&lt;O&gt; &amp;&amp; same_as&lt;iter_value_t&lt;I&gt;, iter_value_t&lt;O&gt;&gt;) ||</span>
<span id="cb1-375"><a href="#cb1-375"></a>                 indirectly_copyable_storable&lt;I, O&gt;)</span>
<span id="cb1-376"><a href="#cb1-376"></a>       constexpr unique_copy_result&lt;I, O&gt;</span>
<span id="cb1-377"><a href="#cb1-377"></a>         unique_copy(I first, S last, O result, C comp = {}, Proj proj = {});</span>
<span id="cb1-378"><a href="#cb1-378"></a>     template&lt;input_range R, weakly_incrementable O, class Proj = identity,</span>
<span id="cb1-379"><a href="#cb1-379"></a>              indirect_equivalence_relation&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; C = ranges::equal_to&gt;</span>
<span id="cb1-380"><a href="#cb1-380"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt; &amp;&amp;</span>
<span id="cb1-381"><a href="#cb1-381"></a>                (forward_iterator&lt;iterator_t&lt;R&gt;&gt; ||</span>
<span id="cb1-382"><a href="#cb1-382"></a>                 (input_iterator&lt;O&gt; &amp;&amp; same_as&lt;range_value_t&lt;R&gt;, iter_value_t&lt;O&gt;&gt;) ||</span>
<span id="cb1-383"><a href="#cb1-383"></a>                 indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, O&gt;)</span>
<span id="cb1-384"><a href="#cb1-384"></a>       constexpr unique_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-385"><a href="#cb1-385"></a>         unique_copy(R&amp;&amp; r, O result, C comp = {}, Proj proj = {});</span>
<span id="cb1-386"><a href="#cb1-386"></a>   }</span>
<span id="cb1-387"><a href="#cb1-387"></a></span>
<span id="cb1-388"><a href="#cb1-388"></a>   <em>[…]</em></span>
<span id="cb1-389"><a href="#cb1-389"></a></span>
<span id="cb1-390"><a href="#cb1-390"></a>   namespace ranges {</span>
<span id="cb1-391"><a href="#cb1-391"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-392"><a href="#cb1-392"></a><span class="st">-    using reverse_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-393"><a href="#cb1-393"></a><span class="va">+    using reverse_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-394"><a href="#cb1-394"></a></span>
<span id="cb1-395"><a href="#cb1-395"></a>     template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;</span>
<span id="cb1-396"><a href="#cb1-396"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-397"><a href="#cb1-397"></a>       constexpr reverse_copy_result&lt;I, O&gt;</span>
<span id="cb1-398"><a href="#cb1-398"></a>         reverse_copy(I first, S last, O result);</span>
<span id="cb1-399"><a href="#cb1-399"></a>     template&lt;bidirectional_range R, weakly_incrementable O&gt;</span>
<span id="cb1-400"><a href="#cb1-400"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-401"><a href="#cb1-401"></a>       constexpr reverse_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-402"><a href="#cb1-402"></a>         reverse_copy(R&amp;&amp; r, O result);</span>
<span id="cb1-403"><a href="#cb1-403"></a>   }</span>
<span id="cb1-404"><a href="#cb1-404"></a></span>
<span id="cb1-405"><a href="#cb1-405"></a>   <em>[…]</em></span>
<span id="cb1-406"><a href="#cb1-406"></a></span>
<span id="cb1-407"><a href="#cb1-407"></a>   namespace ranges {</span>
<span id="cb1-408"><a href="#cb1-408"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-409"><a href="#cb1-409"></a><span class="st">-    using rotate_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-410"><a href="#cb1-410"></a><span class="va">+    using rotate_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-411"><a href="#cb1-411"></a></span>
<span id="cb1-412"><a href="#cb1-412"></a>     template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, weakly_incrementable O&gt;</span>
<span id="cb1-413"><a href="#cb1-413"></a>       requires indirectly_copyable&lt;I, O&gt;</span>
<span id="cb1-414"><a href="#cb1-414"></a>       constexpr rotate_copy_result&lt;I, O&gt;</span>
<span id="cb1-415"><a href="#cb1-415"></a>         rotate_copy(I first, I middle, S last, O result);</span>
<span id="cb1-416"><a href="#cb1-416"></a>     template&lt;forward_range R, weakly_incrementable O&gt;</span>
<span id="cb1-417"><a href="#cb1-417"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-418"><a href="#cb1-418"></a>       constexpr rotate_copy_result&lt;safe_iterator_t&lt;R&gt;, O&gt;</span>
<span id="cb1-419"><a href="#cb1-419"></a>         rotate_copy(R&amp;&amp; r, iterator_t&lt;R&gt; middle, O result);</span>
<span id="cb1-420"><a href="#cb1-420"></a>   }</span>
<span id="cb1-421"><a href="#cb1-421"></a></span>
<span id="cb1-422"><a href="#cb1-422"></a>    <em>[…]</em></span>
<span id="cb1-423"><a href="#cb1-423"></a></span>
<span id="cb1-424"><a href="#cb1-424"></a>   namespace ranges {</span>
<span id="cb1-425"><a href="#cb1-425"></a><span class="st">-    template&lt;class I, class O&gt; using partial_sort_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-426"><a href="#cb1-426"></a><span class="va">+    template&lt;class I, class O&gt;</span></span>
<span id="cb1-427"><a href="#cb1-427"></a><span class="va">+    using partial_sort_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-428"><a href="#cb1-428"></a></span>
<span id="cb1-429"><a href="#cb1-429"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1,</span>
<span id="cb1-430"><a href="#cb1-430"></a>              random_access_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-431"><a href="#cb1-431"></a>              class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-432"><a href="#cb1-432"></a>       requires indirectly_copyable&lt;I1, I2&gt; &amp;&amp; sortable&lt;I2, Comp, Proj2&gt; &amp;&amp;</span>
<span id="cb1-433"><a href="#cb1-433"></a>                indirect_strict_weak_order&lt;Comp, projected&lt;I1, Proj1&gt;, projected&lt;I2, Proj2&gt;&gt;</span>
<span id="cb1-434"><a href="#cb1-434"></a>       constexpr partial_sort_copy_result&lt;I1, I2&gt;</span>
<span id="cb1-435"><a href="#cb1-435"></a>         partial_sort_copy(I1 first, S1 last, I2 result_first, S2 result_last,</span>
<span id="cb1-436"><a href="#cb1-436"></a>                           Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-437"><a href="#cb1-437"></a>     template&lt;input_range R1, random_access_range R2, class Comp = ranges::less,</span>
<span id="cb1-438"><a href="#cb1-438"></a>              class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-439"><a href="#cb1-439"></a>       requires indirectly_copyable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;&gt; &amp;&amp;</span>
<span id="cb1-440"><a href="#cb1-440"></a>                sortable&lt;iterator_t&lt;R2&gt;, Comp, Proj2&gt; &amp;&amp;</span>
<span id="cb1-441"><a href="#cb1-441"></a>                indirect_strict_weak_order&lt;Comp, projected&lt;iterator_t&lt;R1&gt;, Proj1&gt;,</span>
<span id="cb1-442"><a href="#cb1-442"></a>                                           projected&lt;iterator_t&lt;R2&gt;, Proj2&gt;&gt;</span>
<span id="cb1-443"><a href="#cb1-443"></a>       constexpr partial_sort_copy_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;&gt;</span>
<span id="cb1-444"><a href="#cb1-444"></a>         partial_sort_copy(R1&amp;&amp; r, R2&amp;&amp; result_r, Comp comp = {},</span>
<span id="cb1-445"><a href="#cb1-445"></a>                           Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-446"><a href="#cb1-446"></a>   }</span>
<span id="cb1-447"><a href="#cb1-447"></a></span>
<span id="cb1-448"><a href="#cb1-448"></a>   <em>[…]</em></span>
<span id="cb1-449"><a href="#cb1-449"></a></span>
<span id="cb1-450"><a href="#cb1-450"></a>   namespace ranges {</span>
<span id="cb1-451"><a href="#cb1-451"></a>     template&lt;class I, class O1, class O2&gt;</span>
<span id="cb1-452"><a href="#cb1-452"></a><span class="va">+    using partition_copy_result = in_out_out_result&lt;I, O1, O2&gt;;</span></span>
<span id="cb1-453"><a href="#cb1-453"></a><span class="st">-    struct partition_copy_result {</span></span>
<span id="cb1-454"><a href="#cb1-454"></a><span class="st">-      [[no_unique_address]] I  in;</span></span>
<span id="cb1-455"><a href="#cb1-455"></a><span class="st">-      [[no_unique_address]] O1 out1;</span></span>
<span id="cb1-456"><a href="#cb1-456"></a><span class="st">-      [[no_unique_address]] O2 out2;</span></span>
<span id="cb1-457"><a href="#cb1-457"></a><span class="st">-</span></span>
<span id="cb1-458"><a href="#cb1-458"></a><span class="st">-      template&lt;class II, class OO1, class OO2&gt;</span></span>
<span id="cb1-459"><a href="#cb1-459"></a><span class="st">-        requires convertible_to&lt;const I&amp;, II&gt; &amp;&amp;</span></span>
<span id="cb1-460"><a href="#cb1-460"></a><span class="st">-          convertible_to&lt;const O1&amp;, OO1&gt; &amp;&amp; convertible_to&lt;const O2&amp;, OO2&gt;</span></span>
<span id="cb1-461"><a href="#cb1-461"></a><span class="st">-        operator partition_copy_result&lt;II, OO1, OO2&gt;() const &amp; {</span></span>
<span id="cb1-462"><a href="#cb1-462"></a><span class="st">-          return {in, out1, out2};</span></span>
<span id="cb1-463"><a href="#cb1-463"></a><span class="st">-        }</span></span>
<span id="cb1-464"><a href="#cb1-464"></a><span class="st">-</span></span>
<span id="cb1-465"><a href="#cb1-465"></a><span class="st">-      template&lt;class II, class OO1, class OO2&gt;</span></span>
<span id="cb1-466"><a href="#cb1-466"></a><span class="st">-        requires convertible_to&lt;I, II&gt; &amp;&amp;</span></span>
<span id="cb1-467"><a href="#cb1-467"></a><span class="st">-          convertible_to&lt;O1, OO1&gt; &amp;&amp; convertible_to&lt;O2, OO2&gt;</span></span>
<span id="cb1-468"><a href="#cb1-468"></a><span class="st">-        operator partition_copy_result&lt;II, OO1, OO2&gt;() &amp;&amp; {</span></span>
<span id="cb1-469"><a href="#cb1-469"></a><span class="st">-          return {std::move(in), std::move(out1), std::move(out2)};</span></span>
<span id="cb1-470"><a href="#cb1-470"></a><span class="st">-        }</span></span>
<span id="cb1-471"><a href="#cb1-471"></a><span class="st">-    };</span></span>
<span id="cb1-472"><a href="#cb1-472"></a></span>
<span id="cb1-473"><a href="#cb1-473"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S,</span>
<span id="cb1-474"><a href="#cb1-474"></a>              weakly_incrementable O1, weakly_incrementable O2,</span>
<span id="cb1-475"><a href="#cb1-475"></a>              class Proj = identity, indirect_unary_predicate&lt;projected&lt;I, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-476"><a href="#cb1-476"></a>       requires indirectly_copyable&lt;I, O1&gt; &amp;&amp; indirectly_copyable&lt;I, O2&gt;</span>
<span id="cb1-477"><a href="#cb1-477"></a>       constexpr partition_copy_result&lt;I, O1, O2&gt;</span>
<span id="cb1-478"><a href="#cb1-478"></a>         partition_copy(I first, S last, O1 out_true, O2 out_false, Pred pred,</span>
<span id="cb1-479"><a href="#cb1-479"></a>                        Proj proj = {});</span>
<span id="cb1-480"><a href="#cb1-480"></a>     template&lt;input_range R, weakly_incrementable O1, weakly_incrementable O2,</span>
<span id="cb1-481"><a href="#cb1-481"></a>              class Proj = identity,</span>
<span id="cb1-482"><a href="#cb1-482"></a>              indirect_unary_predicate&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Pred&gt;</span>
<span id="cb1-483"><a href="#cb1-483"></a>       requires indirectly_copyable&lt;iterator_t&lt;R&gt;, O1&gt; &amp;&amp;</span>
<span id="cb1-484"><a href="#cb1-484"></a>                indirectly_copyable&lt;iterator_t&lt;R&gt;, O2&gt;</span>
<span id="cb1-485"><a href="#cb1-485"></a>       constexpr partition_copy_result&lt;safe_iterator_t&lt;R&gt;, O1, O2&gt;</span>
<span id="cb1-486"><a href="#cb1-486"></a>         partition_copy(R&amp;&amp; r, O1 out_true, O2 out_false, Pred pred, Proj proj = {});</span>
<span id="cb1-487"><a href="#cb1-487"></a>   }</span>
<span id="cb1-488"><a href="#cb1-488"></a></span>
<span id="cb1-489"><a href="#cb1-489"></a>   <em>[…]</em></span>
<span id="cb1-490"><a href="#cb1-490"></a></span>
<span id="cb1-491"><a href="#cb1-491"></a>   namespace ranges {</span>
<span id="cb1-492"><a href="#cb1-492"></a>     template&lt;class I1, class I2, class O&gt;</span>
<span id="cb1-493"><a href="#cb1-493"></a><span class="st">-    using merge_result = binary_transform_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-494"><a href="#cb1-494"></a><span class="va">+    using merge_result = in_in_out_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-495"><a href="#cb1-495"></a></span>
<span id="cb1-496"><a href="#cb1-496"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-497"><a href="#cb1-497"></a>              weakly_incrementable O, class Comp = ranges::less, class Proj1 = identity,</span>
<span id="cb1-498"><a href="#cb1-498"></a>              class Proj2 = identity&gt;</span>
<span id="cb1-499"><a href="#cb1-499"></a>       requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-500"><a href="#cb1-500"></a>       constexpr merge_result&lt;I1, I2, O&gt;</span>
<span id="cb1-501"><a href="#cb1-501"></a>         merge(I1 first1, S1 last1, I2 first2, S2 last2, O result,</span>
<span id="cb1-502"><a href="#cb1-502"></a>               Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-503"><a href="#cb1-503"></a>     template&lt;input_range R1, input_range R2, weakly_incrementable O, class Comp = ranges::less,</span>
<span id="cb1-504"><a href="#cb1-504"></a>              class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-505"><a href="#cb1-505"></a>       requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-506"><a href="#cb1-506"></a>       constexpr merge_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;</span>
<span id="cb1-507"><a href="#cb1-507"></a>         merge(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,</span>
<span id="cb1-508"><a href="#cb1-508"></a>               Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-509"><a href="#cb1-509"></a>   }</span>
<span id="cb1-510"><a href="#cb1-510"></a></span>
<span id="cb1-511"><a href="#cb1-511"></a>   <em>[…]</em></span>
<span id="cb1-512"><a href="#cb1-512"></a></span>
<span id="cb1-513"><a href="#cb1-513"></a>   namespace ranges {</span>
<span id="cb1-514"><a href="#cb1-514"></a>     template&lt;class I1, class I2, class O&gt;</span>
<span id="cb1-515"><a href="#cb1-515"></a><span class="st">-    using set_union_result = binary_transform_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-516"><a href="#cb1-516"></a><span class="va">+    using set_union_result = in_in_out_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-517"><a href="#cb1-517"></a></span>
<span id="cb1-518"><a href="#cb1-518"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-519"><a href="#cb1-519"></a>              weakly_incrementable O, class Comp = ranges::less,</span>
<span id="cb1-520"><a href="#cb1-520"></a>              class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-521"><a href="#cb1-521"></a>       requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-522"><a href="#cb1-522"></a>       constexpr set_union_result&lt;I1, I2, O&gt;</span>
<span id="cb1-523"><a href="#cb1-523"></a>         set_union(I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp = {},</span>
<span id="cb1-524"><a href="#cb1-524"></a>                   Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-525"><a href="#cb1-525"></a>     template&lt;input_range R1, input_range R2, weakly_incrementable O,</span>
<span id="cb1-526"><a href="#cb1-526"></a>              class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-527"><a href="#cb1-527"></a>       requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-528"><a href="#cb1-528"></a>       constexpr set_union_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;</span>
<span id="cb1-529"><a href="#cb1-529"></a>         set_union(R1&amp;&amp; r1, R2&amp;&amp; r2, O result, Comp comp = {},</span>
<span id="cb1-530"><a href="#cb1-530"></a>                   Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-531"><a href="#cb1-531"></a>   }</span>
<span id="cb1-532"><a href="#cb1-532"></a></span>
<span id="cb1-533"><a href="#cb1-533"></a>   <em>[…]</em></span>
<span id="cb1-534"><a href="#cb1-534"></a></span>
<span id="cb1-535"><a href="#cb1-535"></a>   namespace ranges {</span>
<span id="cb1-536"><a href="#cb1-536"></a>     template&lt;class I1, class I2, class O&gt;</span>
<span id="cb1-537"><a href="#cb1-537"></a><span class="st">-    using set_intersection_result = binary_transform_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-538"><a href="#cb1-538"></a><span class="va">+    using set_intersection_result = in_in_out_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-539"><a href="#cb1-539"></a></span>
<span id="cb1-540"><a href="#cb1-540"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-541"><a href="#cb1-541"></a>              weakly_incrementable O, class Comp = ranges::less,</span>
<span id="cb1-542"><a href="#cb1-542"></a>              class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-543"><a href="#cb1-543"></a>       requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-544"><a href="#cb1-544"></a>       constexpr set_intersection_result&lt;I1, I2, O&gt;</span>
<span id="cb1-545"><a href="#cb1-545"></a>         set_intersection(I1 first1, S1 last1, I2 first2, S2 last2, O result,</span>
<span id="cb1-546"><a href="#cb1-546"></a>                          Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-547"><a href="#cb1-547"></a>     template&lt;input_range R1, input_range R2, weakly_incrementable O,</span>
<span id="cb1-548"><a href="#cb1-548"></a>              class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-549"><a href="#cb1-549"></a>       requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-550"><a href="#cb1-550"></a>       constexpr set_intersection_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;</span>
<span id="cb1-551"><a href="#cb1-551"></a>         set_intersection(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,</span>
<span id="cb1-552"><a href="#cb1-552"></a>                          Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-553"><a href="#cb1-553"></a>   }</span>
<span id="cb1-554"><a href="#cb1-554"></a></span>
<span id="cb1-555"><a href="#cb1-555"></a>   <em>[…]</em></span>
<span id="cb1-556"><a href="#cb1-556"></a></span>
<span id="cb1-557"><a href="#cb1-557"></a>   namespace ranges {</span>
<span id="cb1-558"><a href="#cb1-558"></a>     template&lt;class I, class O&gt;</span>
<span id="cb1-559"><a href="#cb1-559"></a><span class="st">-    using set_difference_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb1-560"><a href="#cb1-560"></a><span class="va">+    using set_difference_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb1-561"><a href="#cb1-561"></a></span>
<span id="cb1-562"><a href="#cb1-562"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-563"><a href="#cb1-563"></a>              weakly_incrementable O, class Comp = ranges::less,</span>
<span id="cb1-564"><a href="#cb1-564"></a>              class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-565"><a href="#cb1-565"></a>       requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-566"><a href="#cb1-566"></a>       constexpr set_difference_result&lt;I1, O&gt;</span>
<span id="cb1-567"><a href="#cb1-567"></a>         set_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,</span>
<span id="cb1-568"><a href="#cb1-568"></a>                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-569"><a href="#cb1-569"></a>     template&lt;input_range R1, input_range R2, weakly_incrementable O,</span>
<span id="cb1-570"><a href="#cb1-570"></a>              class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-571"><a href="#cb1-571"></a>       requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-572"><a href="#cb1-572"></a>       constexpr set_difference_result&lt;safe_iterator_t&lt;R1&gt;, O&gt;</span>
<span id="cb1-573"><a href="#cb1-573"></a>         set_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result,</span>
<span id="cb1-574"><a href="#cb1-574"></a>                        Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-575"><a href="#cb1-575"></a>   }</span>
<span id="cb1-576"><a href="#cb1-576"></a></span>
<span id="cb1-577"><a href="#cb1-577"></a>   <em>[…]</em></span>
<span id="cb1-578"><a href="#cb1-578"></a></span>
<span id="cb1-579"><a href="#cb1-579"></a>   namespace ranges {</span>
<span id="cb1-580"><a href="#cb1-580"></a>     template&lt;class I1, class I2, class O&gt;</span>
<span id="cb1-581"><a href="#cb1-581"></a><span class="st">-    using set_symmetric_difference_result = binary_transform_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-582"><a href="#cb1-582"></a><span class="va">+    using set_symmetric_difference_result = in_in_out_result&lt;I1, I2, O&gt;;</span></span>
<span id="cb1-583"><a href="#cb1-583"></a></span>
<span id="cb1-584"><a href="#cb1-584"></a>     template&lt;input_iterator I1, sentinel_for&lt;I1&gt; S1, input_iterator I2, sentinel_for&lt;I2&gt; S2,</span>
<span id="cb1-585"><a href="#cb1-585"></a>              weakly_incrementable O, class Comp = ranges::less,</span>
<span id="cb1-586"><a href="#cb1-586"></a>              class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-587"><a href="#cb1-587"></a>       requires mergeable&lt;I1, I2, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-588"><a href="#cb1-588"></a>       constexpr set_symmetric_difference_result&lt;I1, I2, O&gt;</span>
<span id="cb1-589"><a href="#cb1-589"></a>         set_symmetric_difference(I1 first1, S1 last1, I2 first2, S2 last2, O result,</span>
<span id="cb1-590"><a href="#cb1-590"></a>                                  Comp comp = {}, Proj1 proj1 = {},</span>
<span id="cb1-591"><a href="#cb1-591"></a>                                  Proj2 proj2 = {});</span>
<span id="cb1-592"><a href="#cb1-592"></a>     template&lt;input_range R1, input_range R2, weakly_incrementable O,</span>
<span id="cb1-593"><a href="#cb1-593"></a>              class Comp = ranges::less, class Proj1 = identity, class Proj2 = identity&gt;</span>
<span id="cb1-594"><a href="#cb1-594"></a>       requires mergeable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, O, Comp, Proj1, Proj2&gt;</span>
<span id="cb1-595"><a href="#cb1-595"></a>       constexpr set_symmetric_difference_result&lt;safe_iterator_t&lt;R1&gt;, safe_iterator_t&lt;R2&gt;, O&gt;</span>
<span id="cb1-596"><a href="#cb1-596"></a>         set_symmetric_difference(R1&amp;&amp; r1, R2&amp;&amp; r2, O result, Comp comp = {},</span>
<span id="cb1-597"><a href="#cb1-597"></a>                                  Proj1 proj1 = {}, Proj2 proj2 = {});</span>
<span id="cb1-598"><a href="#cb1-598"></a>   }</span>
<span id="cb1-599"><a href="#cb1-599"></a></span>
<span id="cb1-600"><a href="#cb1-600"></a>   <em>[…]</em></span>
<span id="cb1-601"><a href="#cb1-601"></a></span>
<span id="cb1-602"><a href="#cb1-602"></a>   namespace ranges {</span>
<span id="cb1-603"><a href="#cb1-603"></a>     template&lt;class T&gt;</span>
<span id="cb1-604"><a href="#cb1-604"></a><span class="va">+    using minmax_result = min_max_result&lt;T&gt;;</span></span>
<span id="cb1-605"><a href="#cb1-605"></a><span class="st">-    struct minmax_result {</span></span>
<span id="cb1-606"><a href="#cb1-606"></a><span class="st">-      [[no_unique_address]] T min;</span></span>
<span id="cb1-607"><a href="#cb1-607"></a><span class="st">-      [[no_unique_address]] T max;</span></span>
<span id="cb1-608"><a href="#cb1-608"></a><span class="st">-</span></span>
<span id="cb1-609"><a href="#cb1-609"></a><span class="st">-      template&lt;class T2&gt;</span></span>
<span id="cb1-610"><a href="#cb1-610"></a><span class="st">-        requires convertible_to&lt;const T&amp;, T2&gt;</span></span>
<span id="cb1-611"><a href="#cb1-611"></a><span class="st">-        operator minmax_result&lt;T2&gt;() const &amp; {</span></span>
<span id="cb1-612"><a href="#cb1-612"></a><span class="st">-          return {min, max};</span></span>
<span id="cb1-613"><a href="#cb1-613"></a><span class="st">-        }</span></span>
<span id="cb1-614"><a href="#cb1-614"></a><span class="st">-</span></span>
<span id="cb1-615"><a href="#cb1-615"></a><span class="st">-      template&lt;class T2&gt;</span></span>
<span id="cb1-616"><a href="#cb1-616"></a><span class="st">-        requires convertible_to&lt;T, T2&gt;</span></span>
<span id="cb1-617"><a href="#cb1-617"></a><span class="st">-        operator minmax_result&lt;T2&gt;() &amp;&amp; {</span></span>
<span id="cb1-618"><a href="#cb1-618"></a><span class="st">-          return {std::move(min), std::move(max)};</span></span>
<span id="cb1-619"><a href="#cb1-619"></a><span class="st">-        }</span></span>
<span id="cb1-620"><a href="#cb1-620"></a><span class="st">-    };</span></span>
<span id="cb1-621"><a href="#cb1-621"></a></span>
<span id="cb1-622"><a href="#cb1-622"></a>     template&lt;class T, class Proj = identity,</span>
<span id="cb1-623"><a href="#cb1-623"></a>              indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;</span>
<span id="cb1-624"><a href="#cb1-624"></a>       constexpr minmax_result&lt;const T&amp;&gt;</span>
<span id="cb1-625"><a href="#cb1-625"></a>         minmax(const T&amp; a, const T&amp; b, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-626"><a href="#cb1-626"></a>     template&lt;copyable T, class Proj = identity,</span>
<span id="cb1-627"><a href="#cb1-627"></a>              indirect_strict_weak_order&lt;projected&lt;const T*, Proj&gt;&gt; Comp = ranges::less&gt;</span>
<span id="cb1-628"><a href="#cb1-628"></a>       constexpr minmax_result&lt;T&gt;</span>
<span id="cb1-629"><a href="#cb1-629"></a>         minmax(initializer_list&lt;T&gt; r, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-630"><a href="#cb1-630"></a>     template&lt;input_range R, class Proj = identity,</span>
<span id="cb1-631"><a href="#cb1-631"></a>              indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;</span>
<span id="cb1-632"><a href="#cb1-632"></a>       requires indirectly_copyable_storable&lt;iterator_t&lt;R&gt;, range_value_t&lt;R&gt;*&gt;</span>
<span id="cb1-633"><a href="#cb1-633"></a>       constexpr minmax_result&lt;range_value_t&lt;R&gt;&gt;</span>
<span id="cb1-634"><a href="#cb1-634"></a>         minmax(R&amp;&amp; r, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-635"><a href="#cb1-635"></a>   }</span>
<span id="cb1-636"><a href="#cb1-636"></a></span>
<span id="cb1-637"><a href="#cb1-637"></a>   <em>[…]</em></span>
<span id="cb1-638"><a href="#cb1-638"></a></span>
<span id="cb1-639"><a href="#cb1-639"></a>   namespace ranges {</span>
<span id="cb1-640"><a href="#cb1-640"></a>     template&lt;class I&gt;</span>
<span id="cb1-641"><a href="#cb1-641"></a><span class="st">-    using minmax_element_result = minmax_result&lt;I&gt;;</span></span>
<span id="cb1-642"><a href="#cb1-642"></a><span class="va">+    using minmax_element_result = min_max_result&lt;I&gt;;</span></span>
<span id="cb1-643"><a href="#cb1-643"></a></span>
<span id="cb1-644"><a href="#cb1-644"></a>     template&lt;forward_iterator I, sentinel_for&lt;I&gt; S, class Proj = identity,</span>
<span id="cb1-645"><a href="#cb1-645"></a>              indirect_strict_weak_order&lt;projected&lt;I, Proj&gt;&gt; Comp = ranges::less&gt;</span>
<span id="cb1-646"><a href="#cb1-646"></a>       constexpr minmax_element_result&lt;I&gt;</span>
<span id="cb1-647"><a href="#cb1-647"></a>         minmax_element(I first, S last, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-648"><a href="#cb1-648"></a>     template&lt;forward_range R, class Proj = identity,</span>
<span id="cb1-649"><a href="#cb1-649"></a>              indirect_strict_weak_order&lt;projected&lt;iterator_t&lt;R&gt;, Proj&gt;&gt; Comp = ranges::less&gt;</span>
<span id="cb1-650"><a href="#cb1-650"></a>       constexpr minmax_element_result&lt;safe_iterator_t&lt;R&gt;&gt;</span>
<span id="cb1-651"><a href="#cb1-651"></a>         minmax_element(R&amp;&amp; r, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-652"><a href="#cb1-652"></a>   }</span>
<span id="cb1-653"><a href="#cb1-653"></a></span>
<span id="cb1-654"><a href="#cb1-654"></a>   <em>[…]</em></span>
<span id="cb1-655"><a href="#cb1-655"></a></span>
<span id="cb1-656"><a href="#cb1-656"></a>   namespace ranges {</span>
<span id="cb1-657"><a href="#cb1-657"></a>     template&lt;class I&gt;</span>
<span id="cb1-658"><a href="#cb1-658"></a><span class="va">+    using next_permutation_result = in_found_result&lt;I&gt;;</span></span>
<span id="cb1-659"><a href="#cb1-659"></a><span class="st">-    struct next_permutation_result {</span></span>
<span id="cb1-660"><a href="#cb1-660"></a><span class="st">-      bool found;</span></span>
<span id="cb1-661"><a href="#cb1-661"></a><span class="st">-      I in;</span></span>
<span id="cb1-662"><a href="#cb1-662"></a><span class="st">-    };</span></span>
<span id="cb1-663"><a href="#cb1-663"></a></span>
<span id="cb1-664"><a href="#cb1-664"></a>     template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,</span>
<span id="cb1-665"><a href="#cb1-665"></a>              class Proj = identity&gt;</span>
<span id="cb1-666"><a href="#cb1-666"></a>       requires sortable&lt;I, Comp, Proj&gt;</span>
<span id="cb1-667"><a href="#cb1-667"></a>       constexpr next_permutation_result&lt;I&gt;</span>
<span id="cb1-668"><a href="#cb1-668"></a>         next_permutation(I first, S last, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-669"><a href="#cb1-669"></a>     template&lt;bidirectional_range R, class Comp = ranges::less,</span>
<span id="cb1-670"><a href="#cb1-670"></a>              class Proj = identity&gt;</span>
<span id="cb1-671"><a href="#cb1-671"></a>       requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;</span>
<span id="cb1-672"><a href="#cb1-672"></a>       constexpr next_permutation_result&lt;safe_iterator_t&lt;R&gt;&gt;</span>
<span id="cb1-673"><a href="#cb1-673"></a>         next_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-674"><a href="#cb1-674"></a>   }</span>
<span id="cb1-675"><a href="#cb1-675"></a></span>
<span id="cb1-676"><a href="#cb1-676"></a>   template&lt;class BidirectionalIterator&gt;</span>
<span id="cb1-677"><a href="#cb1-677"></a>     constexpr bool prev_permutation(BidirectionalIterator first,</span>
<span id="cb1-678"><a href="#cb1-678"></a>                                     BidirectionalIterator last);</span>
<span id="cb1-679"><a href="#cb1-679"></a>   template&lt;class BidirectionalIterator, class Compare&gt;</span>
<span id="cb1-680"><a href="#cb1-680"></a>     constexpr bool prev_permutation(BidirectionalIterator first,</span>
<span id="cb1-681"><a href="#cb1-681"></a>                                     BidirectionalIterator last, Compare comp);</span>
<span id="cb1-682"><a href="#cb1-682"></a></span>
<span id="cb1-683"><a href="#cb1-683"></a>   namespace ranges {</span>
<span id="cb1-684"><a href="#cb1-684"></a>     template&lt;class I&gt;</span>
<span id="cb1-685"><a href="#cb1-685"></a><span class="st">-    using prev_permutation_result = next_permutation_result&lt;I&gt;;</span></span>
<span id="cb1-686"><a href="#cb1-686"></a><span class="va">+    using prev_permutation_result = in_found_result&lt;I&gt;;</span></span>
<span id="cb1-687"><a href="#cb1-687"></a></span>
<span id="cb1-688"><a href="#cb1-688"></a>     template&lt;bidirectional_iterator I, sentinel_for&lt;I&gt; S, class Comp = ranges::less,</span>
<span id="cb1-689"><a href="#cb1-689"></a>              class Proj = identity&gt;</span>
<span id="cb1-690"><a href="#cb1-690"></a>       requires sortable&lt;I, Comp, Proj&gt;</span>
<span id="cb1-691"><a href="#cb1-691"></a>       constexpr prev_permutation_result&lt;I&gt;</span>
<span id="cb1-692"><a href="#cb1-692"></a>         prev_permutation(I first, S last, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-693"><a href="#cb1-693"></a>     template&lt;bidirectional_range R, class Comp = ranges::less,</span>
<span id="cb1-694"><a href="#cb1-694"></a>              class Proj = identity&gt;</span>
<span id="cb1-695"><a href="#cb1-695"></a>       requires sortable&lt;iterator_t&lt;R&gt;, Comp, Proj&gt;</span>
<span id="cb1-696"><a href="#cb1-696"></a>       constexpr prev_permutation_result&lt;safe_iterator_t&lt;R&gt;&gt;</span>
<span id="cb1-697"><a href="#cb1-697"></a>         prev_permutation(R&amp;&amp; r, Comp comp = {}, Proj proj = {});</span>
<span id="cb1-698"><a href="#cb1-698"></a>   }</span>
<span id="cb1-699"><a href="#cb1-699"></a> }</span></code></pre></div>
</div>
<p>Delete <span>25.2 <a href="https://wg21.link/algorithms.requirements">[algorithms.requirements]</a></span> p16:</p>
<div class="rm" style="color: #bf0303">
<p><span class="marginalizedparent"><a class="marginalized">16</a></span> The class templates <code class="sourceCode cpp">binary_­transform_­result</code>, <code class="sourceCode cpp">for_­each_­result</code>, <code class="sourceCode cpp">minmax_­result</code>, <code class="sourceCode cpp">mismatch_­result</code>, <code class="sourceCode cpp">next_­permutation_­result</code>, <code class="sourceCode cpp">copy_­result</code>, and <code class="sourceCode cpp">partition_­copy_­result</code> have the template parameters, data members, and special members specified below. They have no base classes or members other than those specified.</p>
</div>
<p>Add a new subclause after <span>25.4 <a href="https://wg21.link/algorithm.syn">[algorithm.syn]</a></span>, or alternatively under <span>25.2 <a href="https://wg21.link/algorithms.requirements">[algorithms.requirements]</a></span>, as follows:</p>
<div class="add" style="color: #006e28">

<h3 id="algorithm-result-types-algorithms.results" class="unnumbered">?.? Algorithm result types [algorithms.results]<a href="#algorithm-result-types-algorithms.results" class="self-link"></a></h3>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> Each of the class templates specified in this subclause has the template parameters, data members, and special members specified below, and has no base classes or members other than those specified.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I, <span class="kw">class</span> F<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">struct</span> in_fun_result <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I in;</span>
<span id="cb2-4"><a href="#cb2-4"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> F fun;</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I2, <span class="kw">class</span> F2<span class="op">&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I<span class="op">&amp;</span>, I2<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> F<span class="op">&amp;</span>, F2<span class="op">&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_fun_result<span class="op">&lt;</span>I2, F2<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>          <span class="cf">return</span> <span class="op">{</span>in, fun<span class="op">}</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a>        <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I2, <span class="kw">class</span> F2<span class="op">&gt;</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>I, I2<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span>F, F2<span class="op">&gt;</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_fun_result<span class="op">&lt;</span>I2, F2<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>          <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>in<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>fun<span class="op">)}</span>;</span>
<span id="cb2-16"><a href="#cb2-16"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="op">}</span>;</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I1, <span class="kw">class</span> I2<span class="op">&gt;</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>    <span class="kw">struct</span> in_in_result <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I1 in1;</span>
<span id="cb2-22"><a href="#cb2-22"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I2 in2;</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> II1, <span class="kw">class</span> II2<span class="op">&gt;</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I1<span class="op">&amp;</span>, II1<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I2<span class="op">&amp;</span>, II2<span class="op">&gt;</span></span>
<span id="cb2-26"><a href="#cb2-26"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_in_result<span class="op">&lt;</span>II1, II2<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>          <span class="cf">return</span> <span class="op">{</span>in1, in2<span class="op">}</span>;</span>
<span id="cb2-28"><a href="#cb2-28"></a>        <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29"></a></span>
<span id="cb2-30"><a href="#cb2-30"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> II1, <span class="kw">class</span> II2<span class="op">&gt;</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>I1, II1<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span>I2, II2<span class="op">&gt;</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_in_result<span class="op">&lt;</span>II1, II2<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-33"><a href="#cb2-33"></a>          <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>in1<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>in2<span class="op">)}</span>;</span>
<span id="cb2-34"><a href="#cb2-34"></a>        <span class="op">}</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>    <span class="op">}</span>;</span>
<span id="cb2-36"><a href="#cb2-36"></a></span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I, <span class="kw">class</span> O<span class="op">&gt;</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="kw">struct</span> in_out_result <span class="op">{</span></span>
<span id="cb2-39"><a href="#cb2-39"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I in;</span>
<span id="cb2-40"><a href="#cb2-40"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> O out;</span>
<span id="cb2-41"><a href="#cb2-41"></a></span>
<span id="cb2-42"><a href="#cb2-42"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I2, <span class="kw">class</span> O2<span class="op">&gt;</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I<span class="op">&amp;</span>, I2<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> O<span class="op">&amp;</span>, O2<span class="op">&gt;</span></span>
<span id="cb2-44"><a href="#cb2-44"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_out_result<span class="op">&lt;</span>I2, O2<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-45"><a href="#cb2-45"></a>          <span class="cf">return</span> <span class="op">{</span>in, out<span class="op">}</span>;</span>
<span id="cb2-46"><a href="#cb2-46"></a>        <span class="op">}</span></span>
<span id="cb2-47"><a href="#cb2-47"></a></span>
<span id="cb2-48"><a href="#cb2-48"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I2, <span class="kw">class</span> O2<span class="op">&gt;</span></span>
<span id="cb2-49"><a href="#cb2-49"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>I, I2<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span>O, O2<span class="op">&gt;</span></span>
<span id="cb2-50"><a href="#cb2-50"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_out_result<span class="op">&lt;</span>I2, O2<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-51"><a href="#cb2-51"></a>          <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>in<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>out<span class="op">)}</span>;</span>
<span id="cb2-52"><a href="#cb2-52"></a>        <span class="op">}</span></span>
<span id="cb2-53"><a href="#cb2-53"></a>    <span class="op">}</span>;</span>
<span id="cb2-54"><a href="#cb2-54"></a></span>
<span id="cb2-55"><a href="#cb2-55"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I1, <span class="kw">class</span> I2, <span class="kw">class</span> O<span class="op">&gt;</span></span>
<span id="cb2-56"><a href="#cb2-56"></a>    <span class="kw">struct</span> in_in_out_result <span class="op">{</span></span>
<span id="cb2-57"><a href="#cb2-57"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I1 in1;</span>
<span id="cb2-58"><a href="#cb2-58"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I2 in2;</span>
<span id="cb2-59"><a href="#cb2-59"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> O  out;</span>
<span id="cb2-60"><a href="#cb2-60"></a></span>
<span id="cb2-61"><a href="#cb2-61"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> II1, <span class="kw">class</span> II2, <span class="kw">class</span> OO<span class="op">&gt;</span></span>
<span id="cb2-62"><a href="#cb2-62"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I1<span class="op">&amp;</span>, II1<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb2-63"><a href="#cb2-63"></a>          convertible_to<span class="op">&lt;</span><span class="kw">const</span> I2<span class="op">&amp;</span>, II2<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> O<span class="op">&amp;</span>, OO<span class="op">&gt;</span></span>
<span id="cb2-64"><a href="#cb2-64"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_in_out_result<span class="op">&lt;</span>II1, II2, OO<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-65"><a href="#cb2-65"></a>          <span class="cf">return</span> <span class="op">{</span>in1, in2, out<span class="op">}</span>;</span>
<span id="cb2-66"><a href="#cb2-66"></a>        <span class="op">}</span></span>
<span id="cb2-67"><a href="#cb2-67"></a></span>
<span id="cb2-68"><a href="#cb2-68"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> II1, <span class="kw">class</span> II2, <span class="kw">class</span> OO<span class="op">&gt;</span></span>
<span id="cb2-69"><a href="#cb2-69"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>I1, II1<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb2-70"><a href="#cb2-70"></a>          convertible_to<span class="op">&lt;</span>I2, II2<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span>O, OO<span class="op">&gt;</span></span>
<span id="cb2-71"><a href="#cb2-71"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_in_out_result<span class="op">&lt;</span>II1, II2, OO<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-72"><a href="#cb2-72"></a>          <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>in1<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>in2<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>out<span class="op">)}</span>;</span>
<span id="cb2-73"><a href="#cb2-73"></a>        <span class="op">}</span></span>
<span id="cb2-74"><a href="#cb2-74"></a>    <span class="op">}</span>;</span>
<span id="cb2-75"><a href="#cb2-75"></a></span>
<span id="cb2-76"><a href="#cb2-76"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I, <span class="kw">class</span> O1, <span class="kw">class</span> O2<span class="op">&gt;</span></span>
<span id="cb2-77"><a href="#cb2-77"></a>    <span class="kw">struct</span> in_out_out_result <span class="op">{</span></span>
<span id="cb2-78"><a href="#cb2-78"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I  in;</span>
<span id="cb2-79"><a href="#cb2-79"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> O1 out1;</span>
<span id="cb2-80"><a href="#cb2-80"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> O2 out2;</span>
<span id="cb2-81"><a href="#cb2-81"></a></span>
<span id="cb2-82"><a href="#cb2-82"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> II, <span class="kw">class</span> OO1, <span class="kw">class</span> OO2<span class="op">&gt;</span></span>
<span id="cb2-83"><a href="#cb2-83"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I<span class="op">&amp;</span>, II<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb2-84"><a href="#cb2-84"></a>          convertible_to<span class="op">&lt;</span><span class="kw">const</span> O1<span class="op">&amp;</span>, OO1<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> O2<span class="op">&amp;</span>, OO2<span class="op">&gt;</span></span>
<span id="cb2-85"><a href="#cb2-85"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_out_out_result<span class="op">&lt;</span>II, OO1, OO2<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-86"><a href="#cb2-86"></a>          <span class="cf">return</span> <span class="op">{</span>in, out1, out2<span class="op">}</span>;</span>
<span id="cb2-87"><a href="#cb2-87"></a>        <span class="op">}</span></span>
<span id="cb2-88"><a href="#cb2-88"></a></span>
<span id="cb2-89"><a href="#cb2-89"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> II, <span class="kw">class</span> OO1, <span class="kw">class</span> OO2<span class="op">&gt;</span></span>
<span id="cb2-90"><a href="#cb2-90"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>I, II<span class="op">&gt;</span> <span class="op">&amp;&amp;</span></span>
<span id="cb2-91"><a href="#cb2-91"></a>          convertible_to<span class="op">&lt;</span>O1, OO1<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> convertible_to<span class="op">&lt;</span>O2, OO2<span class="op">&gt;</span></span>
<span id="cb2-92"><a href="#cb2-92"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> in_out_out_result<span class="op">&lt;</span>II, OO1, OO2<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-93"><a href="#cb2-93"></a>          <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>in<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>out1<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>out2<span class="op">)}</span>;</span>
<span id="cb2-94"><a href="#cb2-94"></a>        <span class="op">}</span></span>
<span id="cb2-95"><a href="#cb2-95"></a>    <span class="op">}</span>;</span>
<span id="cb2-96"><a href="#cb2-96"></a></span>
<span id="cb2-97"><a href="#cb2-97"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb2-98"><a href="#cb2-98"></a>    <span class="kw">struct</span> min_max_result <span class="op">{</span></span>
<span id="cb2-99"><a href="#cb2-99"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> T min;</span>
<span id="cb2-100"><a href="#cb2-100"></a>      <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> T max;</span>
<span id="cb2-101"><a href="#cb2-101"></a></span>
<span id="cb2-102"><a href="#cb2-102"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb2-103"><a href="#cb2-103"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> T<span class="op">&amp;</span>, T2<span class="op">&gt;</span></span>
<span id="cb2-104"><a href="#cb2-104"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> min_max_result<span class="op">&lt;</span>T2<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-105"><a href="#cb2-105"></a>          <span class="cf">return</span> <span class="op">{</span>min, max<span class="op">}</span>;</span>
<span id="cb2-106"><a href="#cb2-106"></a>        <span class="op">}</span></span>
<span id="cb2-107"><a href="#cb2-107"></a></span>
<span id="cb2-108"><a href="#cb2-108"></a>      <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb2-109"><a href="#cb2-109"></a>        <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>T, T2<span class="op">&gt;</span></span>
<span id="cb2-110"><a href="#cb2-110"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> min_max_result<span class="op">&lt;</span>T2<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-111"><a href="#cb2-111"></a>          <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>min<span class="op">)</span>, std<span class="op">::</span>move<span class="op">(</span>max<span class="op">)}</span>;</span>
<span id="cb2-112"><a href="#cb2-112"></a>        <span class="op">}</span></span>
<span id="cb2-113"><a href="#cb2-113"></a>    <span class="op">}</span>;</span>
<span id="cb2-114"><a href="#cb2-114"></a></span>
<span id="cb2-115"><a href="#cb2-115"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> I<span class="op">&gt;</span></span>
<span id="cb2-116"><a href="#cb2-116"></a>    <span class="kw">struct</span> in_found_result <span class="op">{</span></span>
<span id="cb2-117"><a href="#cb2-117"></a>        <span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span> I in;</span>
<span id="cb2-118"><a href="#cb2-118"></a>        <span class="dt">bool</span> found;</span>
<span id="cb2-119"><a href="#cb2-119"></a></span>
<span id="cb2-120"><a href="#cb2-120"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> I2<span class="op">&gt;</span></span>
<span id="cb2-121"><a href="#cb2-121"></a>          <span class="kw">requires</span> convertible_to<span class="op">&lt;</span><span class="kw">const</span> I<span class="op">&amp;</span>, I2<span class="op">&gt;</span></span>
<span id="cb2-122"><a href="#cb2-122"></a>          <span class="kw">constexpr</span> <span class="kw">operator</span> in_found_result<span class="op">&lt;</span>I2<span class="op">&gt;()</span> <span class="kw">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-123"><a href="#cb2-123"></a>            <span class="cf">return</span> <span class="op">{</span>in, found<span class="op">}</span>;</span>
<span id="cb2-124"><a href="#cb2-124"></a>          <span class="op">}</span></span>
<span id="cb2-125"><a href="#cb2-125"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> I2<span class="op">&gt;</span></span>
<span id="cb2-126"><a href="#cb2-126"></a>          <span class="kw">requires</span> convertible_to<span class="op">&lt;</span>I, I2<span class="op">&gt;</span></span>
<span id="cb2-127"><a href="#cb2-127"></a>          <span class="kw">constexpr</span> <span class="kw">operator</span> in_found_result<span class="op">&lt;</span>I2<span class="op">&gt;()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-128"><a href="#cb2-128"></a>            <span class="cf">return</span> <span class="op">{</span>std<span class="op">::</span>move<span class="op">(</span>in<span class="op">)</span>, found<span class="op">}</span>;</span>
<span id="cb2-129"><a href="#cb2-129"></a>          <span class="op">}</span></span>
<span id="cb2-130"><a href="#cb2-130"></a>    <span class="op">}</span>;</span></code></pre></div>

</div>
<p>Edit <span>25.7.12 <a href="https://wg21.link/alg.permutation.generators">[alg.permutation.generators]</a></span> p4 as indicated:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: Let <code class="sourceCode cpp">B</code> be <code class="sourceCode cpp"><span class="kw">true</span></code> if a next permutation was found and otherwise <code class="sourceCode cpp"><span class="kw">false</span></code>. Returns:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span> <code class="sourceCode cpp">B</code> for the overloads in namespace <code class="sourceCode cpp">std</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span> <span class="diffdel"><code class="sourceCode cpp"><span class="op">{</span> B, last <span class="op">}</span></code></span> <span class="diffins"><code class="sourceCode cpp"><span class="op">{</span>last, B<span class="op">}</span></code></span> for the overloads in namespace <code class="sourceCode cpp">ranges</code>.</li>
</ul>
</blockquote>
<p>Edit <span>25.7.12 <a href="https://wg21.link/alg.permutation.generators">[alg.permutation.generators]</a></span> p9 as indicated:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Returns</em>: Let <code class="sourceCode cpp">B</code> be <code class="sourceCode cpp"><span class="kw">true</span></code> if a previous permutation was found and otherwise <code class="sourceCode cpp"><span class="kw">false</span></code>. Returns:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(9.1)</a></span> <code class="sourceCode cpp">B</code> for the overloads in namespace <code class="sourceCode cpp">std</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(9.2)</a></span> <span class="diffdel"><code class="sourceCode cpp"><span class="op">{</span> B, last <span class="op">}</span></code></span> <span class="diffins"><code class="sourceCode cpp"><span class="op">{</span>last, B<span class="op">}</span></code></span> for the overloads in namespace <code class="sourceCode cpp">ranges</code>.</li>
</ul>
</blockquote>
<p>Edit <span>20.10.2 <a href="https://wg21.link/memory.syn">[memory.syn]</a></span>, header <code class="sourceCode cpp"><span class="op">&lt;</span>memory<span class="op">&gt;</span></code> synopsis, as indicated:</p>
<div>
<div class="sourceCode" id="cb3"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb3-1"><a href="#cb3-1"></a> namespace std {</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>     <em>[…]</em></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>     namespace ranges {</span>
<span id="cb3-6"><a href="#cb3-6"></a>     template&lt;class I, class O&gt;</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="st">-      using uninitialized_copy_result = copy_result&lt;I, O&gt;;</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="va">+      using uninitialized_copy_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S1,</span>
<span id="cb3-10"><a href="#cb3-10"></a>              no-throw-forward-iterator O, no-throw-sentinel&lt;O&gt; S2&gt;</span>
<span id="cb3-11"><a href="#cb3-11"></a>       requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;</span>
<span id="cb3-12"><a href="#cb3-12"></a>         uninitialized_copy_result&lt;I, O&gt;</span>
<span id="cb3-13"><a href="#cb3-13"></a>           uninitialized_copy(I ifirst, S1 ilast, O ofirst, S2 olast);</span>
<span id="cb3-14"><a href="#cb3-14"></a>     template&lt;input_range IR, no-throw-forward-range OR&gt;</span>
<span id="cb3-15"><a href="#cb3-15"></a>       requires constructible_from&lt;range_value_t&lt;OR&gt;, range_reference_t&lt;IR&gt;&gt;</span>
<span id="cb3-16"><a href="#cb3-16"></a>         uninitialized_copy_result&lt;safe_iterator_t&lt;IR&gt;, safe_iterator_t&lt;OR&gt;&gt;</span>
<span id="cb3-17"><a href="#cb3-17"></a>           uninitialized_copy(IR&amp;&amp; in_range, OR&amp;&amp; out_range);</span>
<span id="cb3-18"><a href="#cb3-18"></a></span>
<span id="cb3-19"><a href="#cb3-19"></a>     template&lt;class I, class O&gt;</span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="st">-      using uninitialized_copy_n_result = uninitialized_copy_result&lt;I, O&gt;;</span></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="va">+      using uninitialized_copy_n_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb3-22"><a href="#cb3-22"></a></span>
<span id="cb3-23"><a href="#cb3-23"></a>     template&lt;input_iterator I, no-throw-forward-iterator O, no-throw-sentinel&lt;O&gt; S&gt;</span>
<span id="cb3-24"><a href="#cb3-24"></a>       requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_reference_t&lt;I&gt;&gt;</span>
<span id="cb3-25"><a href="#cb3-25"></a>         uninitialized_copy_n_result&lt;I, O&gt;</span>
<span id="cb3-26"><a href="#cb3-26"></a>           uninitialized_copy_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);</span>
<span id="cb3-27"><a href="#cb3-27"></a>   }</span>
<span id="cb3-28"><a href="#cb3-28"></a></span>
<span id="cb3-29"><a href="#cb3-29"></a>   namespace ranges {</span>
<span id="cb3-30"><a href="#cb3-30"></a>     template&lt;class I, class O&gt;</span>
<span id="cb3-31"><a href="#cb3-31"></a><span class="st">-      using uninitialized_move_result = uninitialized_copy_result&lt;I, O&gt;;</span></span>
<span id="cb3-32"><a href="#cb3-32"></a><span class="va">+      using uninitialized_move_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>     template&lt;input_iterator I, sentinel_for&lt;I&gt; S1,</span>
<span id="cb3-34"><a href="#cb3-34"></a>              no-throw-forward-iterator O, no-throw-sentinel&lt;O&gt; S2&gt;</span>
<span id="cb3-35"><a href="#cb3-35"></a>       requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;</span>
<span id="cb3-36"><a href="#cb3-36"></a>         uninitialized_move_result&lt;I, O&gt;</span>
<span id="cb3-37"><a href="#cb3-37"></a>           uninitialized_move(I ifirst, S1 ilast, O ofirst, S2 olast);</span>
<span id="cb3-38"><a href="#cb3-38"></a>     template&lt;input_range IR, no-throw-forward-range OR&gt;</span>
<span id="cb3-39"><a href="#cb3-39"></a>       requires constructible_from&lt;range_value_t&lt;OR&gt;, range_rvalue_reference_t&lt;IR&gt;&gt;</span>
<span id="cb3-40"><a href="#cb3-40"></a>         uninitialized_move_result&lt;safe_iterator_t&lt;IR&gt;, safe_iterator_t&lt;OR&gt;&gt;</span>
<span id="cb3-41"><a href="#cb3-41"></a>           uninitialized_move(IR&amp;&amp; in_range, OR&amp;&amp; out_range);</span>
<span id="cb3-42"><a href="#cb3-42"></a></span>
<span id="cb3-43"><a href="#cb3-43"></a>     template&lt;class I, class O&gt;</span>
<span id="cb3-44"><a href="#cb3-44"></a><span class="st">-      using uninitialized_move_n_result = uninitialized_copy_result&lt;I, O&gt;;</span></span>
<span id="cb3-45"><a href="#cb3-45"></a><span class="va">+      using uninitialized_move_n_result = in_out_result&lt;I, O&gt;;</span></span>
<span id="cb3-46"><a href="#cb3-46"></a>     template&lt;input_iterator I,</span>
<span id="cb3-47"><a href="#cb3-47"></a>              no-throw-forward-iterator O, no-throw-sentinel&lt;O&gt; S&gt;</span>
<span id="cb3-48"><a href="#cb3-48"></a>       requires constructible_from&lt;iter_value_t&lt;O&gt;, iter_rvalue_reference_t&lt;I&gt;&gt;</span>
<span id="cb3-49"><a href="#cb3-49"></a>         uninitialized_move_n_result&lt;I, O&gt;</span>
<span id="cb3-50"><a href="#cb3-50"></a>           uninitialized_move_n(I ifirst, iter_difference_t&lt;I&gt; n, O ofirst, S olast);</span>
<span id="cb3-51"><a href="#cb3-51"></a>   }</span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a>   <em>[…]</em></span>
<span id="cb3-54"><a href="#cb3-54"></a> }</span></code></pre></div>
</div>
<p>If <a href="https://wg21.link/P1243R4">P1243R4</a> is applied, edit [algorithm.syn] as indicated, immediately before the declaration of <code class="sourceCode cpp">ranges<span class="op">::</span>for_each_n</code>:</p>
<div>
<div class="sourceCode" id="cb4"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb4-1"><a href="#cb4-1"></a> namespace std {</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>   <em>[…]</em></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>   namespace ranges {</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="va">+    template&lt;class I, class F&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="va">+    using for_each_n_result = in_fun_result&lt;I, F&gt;;</span></span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>     template&lt;input_iterator I, class Proj = identity,</span>
<span id="cb4-10"><a href="#cb4-10"></a>              indirectly_unary_invocable&lt;projected&lt;I, Proj&gt;&gt; Fun&gt;</span>
<span id="cb4-11"><a href="#cb4-11"></a>       constexpr for_each_n_result&lt;I, Fun&gt;</span>
<span id="cb4-12"><a href="#cb4-12"></a>         for_each_n(I first, iter_difference_t&lt;I&gt; n, Fun f, Proj proj = {});</span>
<span id="cb4-13"><a href="#cb4-13"></a>   }</span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a>   <em>[…]</em></span>
<span id="cb4-16"><a href="#cb4-16"></a> }</span></code></pre></div>
</div>
<h1 id="references" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> References<a href="#references" class="self-link"></a></h1>

<div id="refs" role="doc-bibliography">
<div id="ref-N4849">
<p>[N4849] Richard Smith. 2020. Working Draft, Standard for Programming Language C++. <br />
<a href="https://wg21.link/n4849">https://wg21.link/n4849</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
